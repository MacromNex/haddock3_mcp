#!/usr/bin/env python3
"""
Script: information_driven_docking.py
Description: Information-driven docking protocol for cyclic peptides using experimental restraints

Original Use Case: examples/use_case_3_information_driven_docking.py
Dependencies Removed: None (was already minimal)

Usage:
    python scripts/information_driven_docking.py --input-protein <protein.pdb> --input-peptide <peptide.pdb> --active-protein <residues> --active-peptide <residues> --output <output_dir>

Example:
    python scripts/information_driven_docking.py --input-protein examples/data/structures/1NX1_protein.pdb --input-peptide examples/data/structures/DAIDALSSDFT_3conformations.pdb --active-protein "36,109,113" --active-peptide "1,5,8" --output results/info_docking_result
"""

# ==============================================================================
# Minimal Imports (only essential packages)
# ==============================================================================
import argparse
import subprocess
import sys
from pathlib import Path
import tempfile
from typing import Union, Optional, Dict, Any, List, Tuple
import json

# ==============================================================================
# Configuration (extracted from use case)
# ==============================================================================
DEFAULT_CONFIG = {
    "ncores": 4,
    "timeout": 14400,  # 4 hours
    "tolerance": 20,
    "scoring_mode": "full",
    "sampling": {
        "fast": {"rigidbody": 100, "flexref": 200},
        "full": {"rigidbody": 1000, "flexref": 400}
    },
    "selection": {
        "top_after_rigidbody": 400,
        "top_after_flexref": 200
    },
    "flexible": {
        "peptide": {"start": 1, "end": 50, "segment": "B"},
        "protein": {"start": 1, "end": 200, "segment": "A"}
    },
    "md_steps": {
        "rigid": 5000,
        "cool1": 5000,
        "cool2": 10000,
        "cool3": 10000,
        "water": 10000
    },
    "clustering": {
        "min_population": 4,
        "clustcutoff": 0.60,
        "top_models": 10
    },
    "temperature": 300
}

# ==============================================================================
# Inlined Utility Functions (simplified from use case)
# ==============================================================================
def create_ambiguous_restraints(active_residues_protein: List[int], active_residues_peptide: List[int],
                               passive_residues_protein: List[int], passive_residues_peptide: List[int],
                               output_file: Path) -> None:
    """
    Create ambiguous interaction restraints (AIRs) based on experimental data.
    Simplified from examples/use_case_3_information_driven_docking.py
    """
    restraints = f"""!
! Ambiguous Interaction Restraints (AIRs) for Information-Driven Docking
! Generated by HADDOCK3 MCP Tool
!
! These restraints are based on experimental data such as:
! - NMR chemical shift perturbations
! - Mutagenesis studies
! - Cross-linking mass spectrometry
! - Hydrogen-deuterium exchange
! - Computational predictions
!

"""

    # Convert lists to residue strings
    active_prot_str = ":".join(map(str, active_residues_protein)) if active_residues_protein else "1"
    passive_prot_str = ":".join(map(str, passive_residues_protein)) if passive_residues_protein else "1"
    active_pep_str = ":".join(map(str, active_residues_peptide)) if active_residues_peptide else "1"
    passive_pep_str = ":".join(map(str, passive_residues_peptide)) if passive_residues_peptide else "1"

    restraints += f"""! Active-Active restraints (strongest experimental evidence)
assign (chain A and resid {active_prot_str}) (chain B and resid {active_pep_str}) 2.0 2.0 0.0

! Active-Passive restraints (medium confidence)
assign (chain A and resid {active_prot_str}) (chain B and resid {passive_pep_str}) 2.0 2.0 0.0
assign (chain A and resid {passive_prot_str}) (chain B and resid {active_pep_str}) 2.0 2.0 0.0

! Passive-Passive restraints (weak evidence, larger distance tolerance)
assign (chain A and resid {passive_prot_str}) (chain B and resid {passive_pep_str}) 2.0 2.0 0.0

"""

    with open(output_file, 'w') as f:
        f.write(restraints)

def create_unambiguous_restraints(distance_restraints: List[Tuple[int, int, float, float]], output_file: Path) -> None:
    """
    Create unambiguous distance restraints from specific experimental data.
    Simplified from use case.
    """
    restraints = """!
! Unambiguous distance restraints from specific experimental data
! Such as NOE distances, cross-linking constraints, etc.
!
"""

    if distance_restraints:
        for res1, res2, distance, tolerance in distance_restraints:
            restraints += f"""! Distance restraint: residue {res1} to residue {res2}
assign (chain A and resid {res1} and name CA) (chain B and resid {res2} and name CA) {distance} {tolerance} {tolerance}

"""
    else:
        restraints += "! No specific distance restraints provided\n"

    with open(output_file, 'w') as f:
        f.write(restraints)

def create_information_driven_config(protein_pdb: str, peptide_pdb: str, ambig_restraints: str,
                                   unambig_restraints: str, output_dir: str, config: Dict[str, Any]) -> str:
    """
    Create HADDOCK3 configuration for information-driven docking.
    Simplified from examples/use_case_3_information_driven_docking.py
    """
    ncores = config.get("ncores", 4)
    tolerance = config.get("tolerance", 20)
    scoring_mode = config.get("scoring_mode", "full")

    # Get sampling parameters based on mode
    sampling = config.get("sampling", {}).get(scoring_mode, {"rigidbody": 1000, "flexref": 400})
    selection = config.get("selection", {})
    flex = config.get("flexible", {})
    md = config.get("md_steps", {})
    cluster = config.get("clustering", {})
    temp = config.get("temperature", 300)

    return f"""# ====================================================================
# Information-Driven Docking Protocol for Cyclic Peptides
# Generated by HADDOCK3 MCP Tool

# directory in which the docking will be done
run_dir = "{output_dir}"

# execution mode
mode = "local"
ncores = {ncores}

# molecules to be docked
molecules = [
    "{protein_pdb}",
    "{peptide_pdb}"
]

# ====================================================================

# Generate topologies with proper protonation states
[topoaa]
autohis = true

# Stage 1: Rigid body docking with experimental restraints
[rigidbody]
tolerance = {tolerance}
ambig_fname = "{ambig_restraints}"
unambig_fname = "{unambig_restraints}"
sampling = {sampling.get("rigidbody", 1000)}
# Enhanced sampling for better exploration
randorien = true
# Use center of mass restraints for better convergence
cmrest = true

# Evaluate docking performance
[caprieval]

# Select top models based on HADDOCK score
[seletop]
select = {selection.get("top_after_rigidbody", 400)}

# Stage 2: Semi-flexible refinement (it1)
[flexref]
tolerance = {tolerance}
ambig_fname = "{ambig_restraints}"
unambig_fname = "{unambig_restraints}"
# Make peptide fully flexible
fle_sta_1 = {flex.get("peptide", {}).get("start", 1)}
fle_end_1 = {flex.get("peptide", {}).get("end", 50)}
fle_seg_1 = "{flex.get("peptide", {}).get("segment", "B")}"
# Flexible protein side chains at interface
fle_sta_2 = {flex.get("protein", {}).get("start", 1)}
fle_end_2 = {flex.get("protein", {}).get("end", 200)}
fle_seg_2 = "{flex.get("protein", {}).get("segment", "A")}"
# Secondary structure restraints for stability
ssdihed = "alphabeta"
# Increased MD steps for thorough sampling
mdsteps_rigid = {md.get("rigid", 5000)}
mdsteps_cool1 = {md.get("cool1", 5000)}
mdsteps_cool2 = {md.get("cool2", 10000)}
mdsteps_cool3 = {md.get("cool3", 10000)}
# Sampling factor for better exploration
sampling_factor = {sampling.get("flexref", 400)}

# Evaluate refined models
[caprieval]

# Select best models for final refinement
[seletop]
select = {selection.get("top_after_flexref", 200)}

# Stage 3: Final explicit water refinement
[mdref]
tolerance = {tolerance}
ambig_fname = "{ambig_restraints}"
unambig_fname = "{unambig_restraints}"
# Keep peptide fully flexible
fle_sta_1 = {flex.get("peptide", {}).get("start", 1)}
fle_end_1 = {flex.get("peptide", {}).get("end", 50)}
fle_seg_1 = "{flex.get("peptide", {}).get("segment", "B")}"
# Flexible protein interface
fle_sta_2 = {flex.get("protein", {}).get("start", 1)}
fle_end_2 = {flex.get("protein", {}).get("end", 200)}
fle_seg_2 = "{flex.get("protein", {}).get("segment", "A")}"
# Extended water simulation
watersteps = {md.get("water", 10000)}
# Temperature for enhanced sampling
finaltemp = {temp}

# Final evaluation
[caprieval]

# Energy minimization
[emref]
tolerance = {tolerance}
ambig_fname = "{ambig_restraints}"
unambig_fname = "{unambig_restraints}"
# Maintain flexibility
fle_sta_1 = {flex.get("peptide", {}).get("start", 1)}
fle_end_1 = {flex.get("peptide", {}).get("end", 50)}
fle_seg_1 = "{flex.get("peptide", {}).get("segment", "B")}"

# Final scoring and evaluation
[caprieval]

# Clustering based on interface contacts
[clustfcc]
min_population = {cluster.get("min_population", 4)}
clustcutoff = {cluster.get("clustcutoff", 0.60)}

# Select representative structures
[seletopclusts]
top_models = {cluster.get("top_models", 10)}

# Final comprehensive evaluation
[caprieval]
allatoms = true

# Additional analysis modules (optional)
[contactmap]
# Generate contact maps for analysis

[trackscore]
# Track score evolution

# ====================================================================
"""

def parse_residue_list(residue_string: str) -> List[int]:
    """Parse comma-separated residue string to list of integers."""
    if not residue_string:
        return []
    return [int(x.strip()) for x in residue_string.split(",") if x.strip()]

def validate_input_file(file_path: Path, file_type: str) -> bool:
    """Validate that input file exists and has correct format."""
    if not file_path.exists():
        raise FileNotFoundError(f"{file_type} file not found: {file_path}")

    if file_type == "pdb" and not file_path.suffix.lower() == ".pdb":
        raise ValueError(f"Expected PDB file, got: {file_path.suffix}")

    return True

def run_haddock3(config_file: Path, work_dir: Path, timeout: int = 14400) -> Tuple[bool, Optional[Path]]:
    """Execute HADDOCK3 information-driven docking. Simplified from use case."""
    try:
        print(f"Running HADDOCK3 information-driven docking: {config_file}")
        print("This protocol uses experimental data to guide the docking...")
        print("Expected runtime: 1-4 hours depending on system size and sampling")

        # Find environment path
        env_path = Path.cwd() / "env"
        if not env_path.exists():
            # Try relative to script
            env_path = Path(__file__).parent.parent / "env"

        # Run HADDOCK3
        result = subprocess.run([
            "mamba", "run", "-p", str(env_path),
            "haddock3", str(config_file)
        ],
        cwd=work_dir,
        capture_output=True,
        text=True,
        timeout=timeout
        )

        if result.returncode == 0:
            print("HADDOCK3 information-driven docking completed successfully!")
            run_dirs = [d for d in work_dir.iterdir() if d.is_dir() and d.name.startswith("run")]
            if run_dirs:
                output_dir = run_dirs[0]
                print(f"Results available in: {output_dir}")
                return True, output_dir
        else:
            print("HADDOCK3 failed!")
            print("STDOUT:", result.stdout)
            print("STDERR:", result.stderr)
            return False, None

    except subprocess.TimeoutExpired:
        print(f"HADDOCK3 timed out after {timeout} seconds")
        return False, None
    except Exception as e:
        print(f"Error running HADDOCK3: {e}")
        return False, None

# ==============================================================================
# Core Function (main logic extracted from use case)
# ==============================================================================
def run_information_driven_docking(
    protein_file: Union[str, Path],
    peptide_file: Union[str, Path],
    active_protein_residues: Optional[List[int]] = None,
    active_peptide_residues: Optional[List[int]] = None,
    passive_protein_residues: Optional[List[int]] = None,
    passive_peptide_residues: Optional[List[int]] = None,
    distance_restraints: Optional[List[Tuple[int, int, float, float]]] = None,
    output_dir: Optional[Union[str, Path]] = None,
    config: Optional[Dict[str, Any]] = None,
    work_dir: Optional[Union[str, Path]] = None,
    dry_run: bool = False,
    **kwargs
) -> Dict[str, Any]:
    """
    Main function for information-driven docking using HADDOCK3.

    Args:
        protein_file: Path to protein PDB file
        peptide_file: Path to peptide PDB file
        active_protein_residues: List of active residues on protein (strong experimental evidence)
        active_peptide_residues: List of active residues on peptide (strong experimental evidence)
        passive_protein_residues: List of passive residues on protein (weak evidence/neighbors)
        passive_peptide_residues: List of passive residues on peptide (weak evidence/neighbors)
        distance_restraints: List of (res1, res2, distance, tolerance) tuples
        output_dir: Output directory name for results
        config: Configuration dict (uses DEFAULT_CONFIG if not provided)
        work_dir: Working directory for HADDOCK3 (default: ./info_docking_work)
        dry_run: Only create configuration file, don't run HADDOCK3
        **kwargs: Override specific config parameters

    Returns:
        Dict containing:
            - success: Whether docking completed successfully
            - output_dir: Path to output directory (if successful)
            - config_file: Path to configuration file
            - restraints_files: Dict with ambiguous and unambiguous restraints file paths
            - work_dir: Working directory used
            - restraints_info: Summary of restraints used
            - metadata: Execution metadata

    Example:
        >>> result = run_information_driven_docking("protein.pdb", "peptide.pdb",
        ...                                        active_protein_residues=[36, 109, 113],
        ...                                        active_peptide_residues=[1, 5, 8])
        >>> print(result['output_dir'])
    """
    # Setup
    protein_file = Path(protein_file)
    peptide_file = Path(peptide_file)
    config = {**DEFAULT_CONFIG, **(config or {}), **kwargs}

    if output_dir is None:
        output_dir = "information_driven_docking"

    if work_dir is None:
        work_dir = Path("./info_docking_work")
    else:
        work_dir = Path(work_dir)

    # Validate inputs
    validate_input_file(protein_file, "protein")
    validate_input_file(peptide_file, "peptide")

    # Use default restraints if none provided (from demo data)
    if not any([active_protein_residues, passive_protein_residues, active_peptide_residues, passive_peptide_residues]):
        print("No experimental restraints provided. Using example restraints...")
        active_protein_residues = [36, 109, 113]  # From demo data
        active_peptide_residues = [1, 5, 8]
        passive_protein_residues = [34, 38, 110, 111]
        passive_peptide_residues = [2, 6, 9]

    # Set defaults for missing restraints
    active_protein_residues = active_protein_residues or []
    active_peptide_residues = active_peptide_residues or []
    passive_protein_residues = passive_protein_residues or []
    passive_peptide_residues = passive_peptide_residues or []
    distance_restraints = distance_restraints or []

    # Create working directory
    work_dir.mkdir(exist_ok=True)

    # Create restraints files
    ambig_file = work_dir / "ambiguous_restraints.tbl"
    unambig_file = work_dir / "distance_restraints.tbl"

    create_ambiguous_restraints(active_protein_residues, active_peptide_residues,
                              passive_protein_residues, passive_peptide_residues, ambig_file)
    create_unambiguous_restraints(distance_restraints, unambig_file)

    print(f"Restraints created:")
    print(f"  Active protein residues: {active_protein_residues}")
    print(f"  Active peptide residues: {active_peptide_residues}")
    print(f"  Passive protein residues: {passive_protein_residues}")
    print(f"  Passive peptide residues: {passive_peptide_residues}")
    print(f"  Distance restraints: {len(distance_restraints)}")

    # Generate configuration file
    config_content = create_information_driven_config(
        protein_pdb=str(protein_file.resolve()),
        peptide_pdb=str(peptide_file.resolve()),
        ambig_restraints=str(ambig_file.resolve()),
        unambig_restraints=str(unambig_file.resolve()),
        output_dir=output_dir,
        config=config
    )

    config_file = work_dir / "info_docking_config.cfg"
    with open(config_file, 'w') as f:
        f.write(config_content)

    result = {
        "success": False,
        "output_dir": None,
        "config_file": str(config_file),
        "restraints_files": {
            "ambiguous": str(ambig_file),
            "unambiguous": str(unambig_file)
        },
        "work_dir": str(work_dir),
        "restraints_info": {
            "active_protein": active_protein_residues,
            "active_peptide": active_peptide_residues,
            "passive_protein": passive_protein_residues,
            "passive_peptide": passive_peptide_residues,
            "distance_restraints": len(distance_restraints)
        },
        "metadata": {
            "protein_file": str(protein_file),
            "peptide_file": str(peptide_file),
            "config": config,
            "dry_run": dry_run
        }
    }

    print(f"Configuration file created: {config_file}")

    if dry_run:
        print("Dry run completed. Files ready for manual execution.")
        result["success"] = True
        return result

    # Run HADDOCK3
    success, output_path = run_haddock3(config_file, work_dir, config.get("timeout", 14400))

    result["success"] = success
    if success and output_path:
        result["output_dir"] = str(output_path)

    return result

# ==============================================================================
# CLI Interface
# ==============================================================================
def main():
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument('--input-protein', '-p', required=True,
                       help='Input protein PDB file path')
    parser.add_argument('--input-peptide', '-e', required=True,
                       help='Input peptide PDB file path')
    parser.add_argument('--active-protein',
                       help='Comma-separated list of active residues on protein (strong evidence)')
    parser.add_argument('--passive-protein',
                       help='Comma-separated list of passive residues on protein (weak evidence)')
    parser.add_argument('--active-peptide',
                       help='Comma-separated list of active residues on peptide (strong evidence)')
    parser.add_argument('--passive-peptide',
                       help='Comma-separated list of passive residues on peptide (weak evidence)')
    parser.add_argument('--distance-restraints',
                       help='File with specific distance restraints (format: res1,res2,distance,tolerance per line)')
    parser.add_argument('--output', '-o', default="information_driven_docking",
                       help='Output directory name')
    parser.add_argument('--config', '-c',
                       help='Config file (JSON)')
    parser.add_argument('--work-dir', '-w', default="./info_docking_work",
                       help='Working directory for HADDOCK3')
    parser.add_argument('--scoring-mode', choices=["fast", "full"], default="full",
                       help='Scoring mode: fast (less sampling) or full (thorough)')
    parser.add_argument('--ncores', type=int,
                       help='Number of CPU cores to use')
    parser.add_argument('--dry-run', action="store_true",
                       help='Only create configuration file, dont run HADDOCK3')

    args = parser.parse_args()

    # Load config if provided
    config = None
    if args.config:
        with open(args.config) as f:
            config = json.load(f)

    # Parse residue lists
    active_prot = parse_residue_list(args.active_protein) if args.active_protein else None
    passive_prot = parse_residue_list(args.passive_protein) if args.passive_protein else None
    active_pep = parse_residue_list(args.active_peptide) if args.active_peptide else None
    passive_pep = parse_residue_list(args.passive_peptide) if args.passive_peptide else None

    # Parse distance restraints if provided
    distance_restraints = []
    if args.distance_restraints:
        try:
            with open(args.distance_restraints, 'r') as f:
                for line in f:
                    if line.strip() and not line.startswith('#'):
                        parts = line.strip().split(',')
                        if len(parts) == 4:
                            res1, res2, dist, tol = parts
                            distance_restraints.append((int(res1), int(res2), float(dist), float(tol)))
        except Exception as e:
            print(f"Error reading distance restraints: {e}")
            return 1

    # Override config with CLI arguments
    cli_overrides = {}
    if args.ncores:
        cli_overrides["ncores"] = args.ncores
    if args.scoring_mode:
        cli_overrides["scoring_mode"] = args.scoring_mode

    # Run
    try:
        result = run_information_driven_docking(
            protein_file=args.input_protein,
            peptide_file=args.input_peptide,
            active_protein_residues=active_prot,
            active_peptide_residues=active_pep,
            passive_protein_residues=passive_prot,
            passive_peptide_residues=passive_pep,
            distance_restraints=distance_restraints,
            output_dir=args.output,
            config=config,
            work_dir=args.work_dir,
            dry_run=args.dry_run,
            **cli_overrides
        )

        if result["success"]:
            if args.dry_run:
                print("‚úÖ Configuration created successfully")
                print(f"Config file: {result['config_file']}")
                print(f"Restraints files: {result['restraints_files']}")
            else:
                print("üéâ Information-driven docking completed successfully!")
                print(f"Results are in: {result['output_dir']}")
                print("Next steps:")
                print("1. Analyze the clustered solutions")
                print("2. Validate against experimental data")
                print("3. Check interface quality and binding scores")
        else:
            print("‚ùå Docking failed. Check restraints and input files.")
            return 1

        return 0

    except Exception as e:
        print(f"Error: {e}")
        return 1

if __name__ == '__main__':
    main()