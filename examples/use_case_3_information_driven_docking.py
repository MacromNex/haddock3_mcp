#!/usr/bin/env python3
"""
Use Case 3: Information-Driven Docking Protocol for Cyclic Peptides

This script demonstrates HADDOCK3's information-driven docking approach,
which incorporates experimental or computational data to guide the docking
process. This is particularly powerful for cyclic peptide-protein interactions
where you have some experimental information about the binding site.

Author: HADDOCK3 MCP Tool
Usage: python examples/use_case_3_information_driven_docking.py [options]
"""

import argparse
import subprocess
import sys
from pathlib import Path
import tempfile


def create_ambiguous_restraints(active_residues_protein, active_residues_peptide,
                               passive_residues_protein, passive_residues_peptide,
                               output_file):
    """
    Create ambiguous interaction restraints (AIRs) based on experimental data.

    Args:
        active_residues_protein (list): Active residues on protein
        active_residues_peptide (list): Active residues on peptide
        passive_residues_protein (list): Passive residues on protein
        passive_residues_peptide (list): Passive residues on peptide
        output_file (str): Path to output restraints file
    """
    restraints = f"""!
! Ambiguous Interaction Restraints (AIRs) for Information-Driven Docking
! Generated by HADDOCK3 MCP Tool
!
! These restraints are based on experimental data such as:
! - NMR chemical shift perturbations
! - Mutagenesis studies
! - Cross-linking mass spectrometry
! - Hydrogen-deuterium exchange
! - Computational predictions
!

"""

    # Convert lists to residue strings
    active_prot_str = ":".join(map(str, active_residues_protein)) if active_residues_protein else "1"
    passive_prot_str = ":".join(map(str, passive_residues_protein)) if passive_residues_protein else "1"
    active_pep_str = ":".join(map(str, active_residues_peptide)) if active_residues_peptide else "1"
    passive_pep_str = ":".join(map(str, passive_residues_peptide)) if passive_residues_peptide else "1"

    restraints += f"""! Active-Active restraints (strongest experimental evidence)
assign (chain A and resid {active_prot_str}) (chain B and resid {active_pep_str}) 2.0 2.0 0.0

! Active-Passive restraints (medium confidence)
assign (chain A and resid {active_prot_str}) (chain B and resid {passive_pep_str}) 2.0 2.0 0.0
assign (chain A and resid {passive_prot_str}) (chain B and resid {active_pep_str}) 2.0 2.0 0.0

! Passive-Passive restraints (weak evidence, larger distance tolerance)
assign (chain A and resid {passive_prot_str}) (chain B and resid {passive_pep_str}) 2.0 2.0 0.0

"""

    with open(output_file, 'w') as f:
        f.write(restraints)


def create_unambiguous_restraints(distance_restraints, output_file):
    """
    Create unambiguous distance restraints from specific experimental data.

    Args:
        distance_restraints (list): List of tuples (res1, res2, distance, tolerance)
        output_file (str): Path to output restraints file
    """
    restraints = """!
! Unambiguous distance restraints from specific experimental data
! Such as NOE distances, cross-linking constraints, etc.
!
"""

    if distance_restraints:
        for res1, res2, distance, tolerance in distance_restraints:
            restraints += f"""! Distance restraint: residue {res1} to residue {res2}
assign (chain A and resid {res1} and name CA) (chain B and resid {res2} and name CA) {distance} {tolerance} {tolerance}

"""
    else:
        restraints += "! No specific distance restraints provided\\n"

    with open(output_file, 'w') as f:
        f.write(restraints)


def create_information_driven_config(protein_pdb, peptide_pdb, ambig_restraints,
                                   unambig_restraints, output_dir, ncores=4,
                                   scoring_mode="full"):
    """
    Create HADDOCK3 configuration for information-driven docking.

    Args:
        protein_pdb (str): Path to protein PDB file
        peptide_pdb (str): Path to peptide PDB file
        ambig_restraints (str): Path to ambiguous restraints file
        unambig_restraints (str): Path to unambiguous restraints file
        output_dir (str): Output directory name
        ncores (int): Number of CPU cores to use
        scoring_mode (str): "full" or "fast" scoring

    Returns:
        str: Configuration file content
    """

    # Adjust sampling based on scoring mode
    if scoring_mode == "fast":
        rb_sampling = 100
        it1_sampling = 200
    else:
        rb_sampling = 1000
        it1_sampling = 400

    config = f"""# ====================================================================
# Information-Driven Docking Protocol for Cyclic Peptides
# Generated by HADDOCK3 MCP Tool

# directory in which the docking will be done
run_dir = "{output_dir}"

# execution mode
mode = "local"
ncores = {ncores}

# molecules to be docked
molecules = [
    "{protein_pdb}",
    "{peptide_pdb}"
]

# ====================================================================

# Generate topologies with proper protonation states
[topoaa]
autohis = true

# Stage 1: Rigid body docking with experimental restraints
[rigidbody]
tolerance = 20
ambig_fname = "{ambig_restraints}"
unambig_fname = "{unambig_restraints}"
sampling = {rb_sampling}
# Enhanced sampling for better exploration
randorien = true
# Use center of mass restraints for better convergence
cmrest = true
# Symmetry restraints if applicable
# ncs = true

# Evaluate docking performance
[caprieval]

# Select top models based on HADDOCK score
[seletop]
select = 400

# Stage 2: Semi-flexible refinement (it1)
[flexref]
tolerance = 20
ambig_fname = "{ambig_restraints}"
unambig_fname = "{unambig_restraints}"
# Make peptide fully flexible
fle_sta_1 = 1
fle_end_1 = 50
fle_seg_1 = "B"
# Flexible protein side chains at interface
fle_sta_2 = 1
fle_end_2 = 200
fle_seg_2 = "A"
# Secondary structure restraints for stability
ssdihed = "alphabeta"
# Increased MD steps for thorough sampling
mdsteps_rigid = 5000
mdsteps_cool1 = 5000
mdsteps_cool2 = 10000
mdsteps_cool3 = 10000
# Sampling factor for better exploration
sampling_factor = {it1_sampling}

# Evaluate refined models
[caprieval]

# Select best models for final refinement
[seletop]
select = 200

# Stage 3: Final explicit water refinement
[mdref]
tolerance = 20
ambig_fname = "{ambig_restraints}"
unambig_fname = "{unambig_restraints}"
# Keep peptide fully flexible
fle_sta_1 = 1
fle_end_1 = 50
fle_seg_1 = "B"
# Flexible protein interface
fle_sta_2 = 1
fle_end_2 = 200
fle_seg_2 = "A"
# Extended water simulation
watersteps = 10000
# Temperature for enhanced sampling
finaltemp = 300

# Final evaluation
[caprieval]

# Energy minimization
[emref]
tolerance = 20
ambig_fname = "{ambig_restraints}"
unambig_fname = "{unambig_restraints}"
# Maintain flexibility
fle_sta_1 = 1
fle_end_1 = 50
fle_seg_1 = "B"

# Final scoring and evaluation
[caprieval]

# Clustering based on interface contacts
[clustfcc]
min_population = 4
clustcutoff = 0.60

# Select representative structures
[seletopclusts]
top_models = 10

# Final comprehensive evaluation
[caprieval]
allatoms = true

# Additional analysis modules (optional)
[contactmap]
# Generate contact maps for analysis

[trackscore]
# Track score evolution

# ====================================================================
"""
    return config


def run_haddock3_information_driven(config_file, work_dir):
    """
    Execute HADDOCK3 information-driven docking.

    Args:
        config_file (str): Path to configuration file
        work_dir (str): Working directory

    Returns:
        tuple: (success, output_dir)
    """
    try:
        original_dir = Path.cwd()
        Path(work_dir).mkdir(exist_ok=True)

        print(f"Running HADDOCK3 information-driven docking: {config_file}")
        print("This protocol uses experimental data to guide the docking...")
        print("Expected runtime: 1-4 hours depending on system size and sampling")

        # Run HADDOCK3
        result = subprocess.run([
            "mamba", "run", "-p", str(original_dir / "env"),
            "haddock3", str(config_file)
        ],
        cwd=work_dir,
        capture_output=True,
        text=True,
        timeout=14400  # 4 hour timeout
        )

        if result.returncode == 0:
            print("HADDOCK3 information-driven docking completed successfully!")
            run_dirs = [d for d in Path(work_dir).iterdir() if d.is_dir() and d.name.startswith("run")]
            if run_dirs:
                output_dir = run_dirs[0]
                print(f"Results available in: {output_dir}")
                return True, output_dir
        else:
            print("HADDOCK3 failed!")
            print("STDOUT:", result.stdout)
            print("STDERR:", result.stderr)
            return False, None

    except subprocess.TimeoutExpired:
        print("HADDOCK3 timed out after 4 hours")
        return False, None
    except Exception as e:
        print(f"Error running HADDOCK3: {e}")
        return False, None


def main():
    parser = argparse.ArgumentParser(
        description="Run information-driven docking for cyclic peptides using HADDOCK3",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    # Basic usage with demo data and predefined restraints
    python examples/use_case_3_information_driven_docking.py

    # Custom proteins with experimental restraints
    python examples/use_case_3_information_driven_docking.py \\
        --protein my_protein.pdb \\
        --peptide my_cyclic_peptide.pdb \\
        --active-protein "10,15,23,45" \\
        --active-peptide "3,7,11" \\
        --passive-protein "8,12,25,47" \\
        --passive-peptide "1,5,9"

    # High-throughput mode
    python examples/use_case_3_information_driven_docking.py \\
        --protein examples/data/structures/1NX1_protein.pdb \\
        --peptide examples/data/structures/DAIDALSSDFT_3conformations.pdb \\
        --scoring-mode fast \\
        --ncores 20

Note: Active residues should have strong experimental evidence for binding,
passive residues should have weaker evidence or be interface neighbors.
        """
    )

    parser.add_argument("--protein",
                       default="examples/data/structures/1NX1_protein.pdb",
                       help="Path to protein PDB file")

    parser.add_argument("--peptide",
                       default="examples/data/structures/DAIDALSSDFT_3conformations.pdb",
                       help="Path to peptide PDB file")

    parser.add_argument("--active-protein",
                       default="",
                       help="Comma-separated list of active residues on protein")

    parser.add_argument("--passive-protein",
                       default="",
                       help="Comma-separated list of passive residues on protein")

    parser.add_argument("--active-peptide",
                       default="",
                       help="Comma-separated list of active residues on peptide")

    parser.add_argument("--passive-peptide",
                       default="",
                       help="Comma-separated list of passive residues on peptide")

    parser.add_argument("--distance-restraints",
                       help="File with specific distance restraints (format: res1,res2,distance,tolerance per line)")

    parser.add_argument("--scoring-mode",
                       choices=["fast", "full"],
                       default="full",
                       help="Scoring mode: fast (less sampling) or full (thorough)")

    parser.add_argument("--output",
                       default="information_driven_docking",
                       help="Output directory name")

    parser.add_argument("--ncores", type=int, default=4,
                       help="Number of CPU cores to use")

    parser.add_argument("--work-dir",
                       default="./info_docking_work",
                       help="Working directory for HADDOCK3")

    parser.add_argument("--dry-run", action="store_true",
                       help="Only create configuration files, don't run HADDOCK3")

    args = parser.parse_args()

    # Check if input files exist
    protein_path = Path(args.protein)
    peptide_path = Path(args.peptide)

    if not protein_path.exists():
        print(f"Error: Protein file not found: {protein_path}")
        return 1

    if not peptide_path.exists():
        print(f"Error: Peptide file not found: {peptide_path}")
        return 1

    # Parse residue lists
    active_prot = [int(x.strip()) for x in args.active_protein.split(",") if x.strip()]
    passive_prot = [int(x.strip()) for x in args.passive_protein.split(",") if x.strip()]
    active_pep = [int(x.strip()) for x in args.active_peptide.split(",") if x.strip()]
    passive_pep = [int(x.strip()) for x in args.passive_peptide.split(",") if x.strip()]

    # Use default restraints if none provided
    if not any([active_prot, passive_prot, active_pep, passive_pep]):
        print("No experimental restraints provided. Using example restraints...")
        active_prot = [36, 109, 113]  # From demo data
        active_pep = [1, 5, 8]
        passive_prot = [34, 38, 110, 111]
        passive_pep = [2, 6, 9]

    # Parse distance restraints if provided
    distance_restraints = []
    if args.distance_restraints:
        try:
            with open(args.distance_restraints, 'r') as f:
                for line in f:
                    if line.strip() and not line.startswith('#'):
                        parts = line.strip().split(',')
                        if len(parts) == 4:
                            res1, res2, dist, tol = parts
                            distance_restraints.append((int(res1), int(res2), float(dist), float(tol)))
        except Exception as e:
            print(f"Error reading distance restraints: {e}")
            return 1

    # Create working directory
    work_dir = Path(args.work_dir)
    work_dir.mkdir(exist_ok=True)

    # Create restraints files
    ambig_file = work_dir / "ambiguous_restraints.tbl"
    unambig_file = work_dir / "distance_restraints.tbl"

    create_ambiguous_restraints(active_prot, active_pep, passive_prot, passive_pep, ambig_file)
    create_unambiguous_restraints(distance_restraints, unambig_file)

    print(f"Restraints created:")
    print(f"  Active protein residues: {active_prot}")
    print(f"  Active peptide residues: {active_pep}")
    print(f"  Passive protein residues: {passive_prot}")
    print(f"  Passive peptide residues: {passive_pep}")
    print(f"  Distance restraints: {len(distance_restraints)}")

    # Generate configuration file
    config_content = create_information_driven_config(
        protein_pdb=str(protein_path.resolve()),
        peptide_pdb=str(peptide_path.resolve()),
        ambig_restraints=str(ambig_file.resolve()),
        unambig_restraints=str(unambig_file.resolve()),
        output_dir=args.output,
        ncores=args.ncores,
        scoring_mode=args.scoring_mode
    )

    config_file = work_dir / "info_docking_config.cfg"
    with open(config_file, 'w') as f:
        f.write(config_content)

    print(f"Configuration file created: {config_file}")

    if args.dry_run:
        print("Dry run completed. Files ready for manual execution.")
        print(f"To run: mamba activate ./env && cd {work_dir} && haddock3 {config_file.name}")
        return 0

    # Run HADDOCK3
    success, output_dir = run_haddock3_information_driven(config_file, work_dir)

    if success:
        print(f"\\nüéâ Information-driven docking completed successfully!")
        print(f"Results are in: {output_dir}")
        print(f"\\nNext steps:")
        print(f"1. Analyze the clustered solutions")
        print(f"2. Validate against experimental data")
        print(f"3. Check interface quality and binding scores")
        print(f"4. Compare with known structures if available")
        return 0
    else:
        print("\\n‚ùå Docking failed. Check restraints and input files.")
        return 1


if __name__ == "__main__":
    sys.exit(main())